OQL[C++]: Extending C++ with an Object Query Capability.
Transaction Management in Multidatabase Systems.
Overview of the ADDS System.
Multimedia Information Systems: Issues and Approaches.
Active Database Systems.
Where Object-Oriented DBMSs Should Do Better: A Critique Based on Early Experiences.
Distributed Databases.
An Object-Oriented DBMS War Story: Developing a Genome Mapping Database in C++.
Cooperative Transactions for Multiuser Environments.
Schema Architecture of the UniSQL/M Multidatabase System
Physical Object Management.
Introduction to Part 1: Next-Generation Database Technology.
Object-Oriented Database Systems: Promises, Reality, and Future.
Introduction to Part 2: Technology for Interoperating Legacy Databases.
On Resolving Schematic Heterogeneity in Multidatabase Systems.
Requirements for a Performance Benchmark for Object-Oriented Database Systems.
On View Support in Object-Oriented Databases Systems.
The POSC Solution to Managing E&P Data.
C++ Bindings to an Object Database.
Authorization in Object-Oriented Databases.
Query Processing in Multidatabase Systems.
Management of Uncerainty in database Systems.
Parallel Relational Database Systems.
Query Processing in Object-Oriented Database Systems.
Specification and Execution of Transactional Workflows.
Spatial Data Structures.
An overview is presented of the use of spatial data structures in spatial databases. The focus is on hierarchical data structures, including a number of variants of quadtrees, which sort the data with respect to the space occupied by it. Such techniques are known as spatial indexing methods. Hierarchical data structures are based on the principle of recursive decomposition. They are attractive because they are compact and depending on the nature of the data they save space as well as time and also facilitate operations such as search. Examples are given of the use of these data structures in the representation of different data types such as regions, points, rectangles, lines, and volumes.
Spatial Data Models and Query Processing.
Pegasus: A Heterogeneous Information Management System.
Temporal Object-Oriented Databases: A Critical Comparison.
The OMG Object Model.
EDA/SQL.
The Changing Database Standards Landscape.
Modern Database Systems: The Object Model, Interoperability, and Beyond.
Inequalities: Theory of Majorization and Its Application.
Version Control in an Object-Oriented Architecture.
The GemStone Data Management System.
Storage Management in EXODUS.
A Distributed Object Manager for the Smalltalk-80 System.
Objects, Messages, and Rules in Database Design.
Active Objects: Ealities and Possibilities.
Overview of the Iris DBMS.
Features of the ORION Object-Oriented Database System.
Indexing Techniques for Object-Oriented Databases.
My Cat Is Object-Oriented.
Making Database Systems Fast Enough for CAD Applications.
Optimizing Smalltalk Message Performance.
The Common List Object-Oriented Programming Language Standard.
Object Orientation as Catalyst for Language-Database Inegration.
A Survey of Object-Oriented Concepts.
Integrated Office Systems.
Proteus: A Frame-Based Nonmonotonic Inference System.
Concurrency Control and Object-Oriented Databases.
A Shared View of Sharing: The Treaty of Orlando.
Pogo: A Declarative Representation System for Graphics.
Concurrent Object-Oriented Programming Languages.
Directions in Object-Oriented Research.
A Proposal for a Formal Model of Objects.
OZ+: An Object-Oriented Database System.
The Commercial INGRES Epilogue.
Design of Relational Systems (Introduction to Section 1).
Supporting Studies on Relational Systems (Introduction to Section 2).
Distributed Database Systems (Introduction to Section 3).
The Design and Implementation of Distributed INGRES.
User Interfaces for Database Systems (Introduction to Section 4).
Extended Semantics for the Relational Model (Introduction to Section 5).
Database Design (Introduction to Section 6).
Title, Preface, Contents.
References.
TeX: The Program
Foundations of Databases.
LaTeX: User's Guide & Reference Manual
The Design and Analysis of Computer Algorithms.
Specifying Systems, The TLA+ Language and Tools for Hardware and Software Engineers
From the Book: This book will teach you how to write specifications of computer systems, using the language TLA+. It's rather long, but most people will read only Part I, which comprises the first 83 pages. That part contains all that most engineers need to know about writing specifications; it assumes only the basic background in computing and knowledge of mathematics expected of an undergraduate studying engineering or computer science. Part II contains more advanced material for more sophisticated readers. The remainder of the book is a reference manualPart III for the TLA+ tools and Part IV for the language itself. The TLA World Wide Web page contains material to accompany the book, including the TLA+ tools, exercises, references to the literature, and a list of corrections. There is a link to the TLA Web page on http://lamport.org.What Is a Specification?Writing is nature's way of letting you know how sloppy your thinking is.-GuindonA specification is a written description of what a system is supposed to do. Specifying a system helps us understand it. It's a good idea to understand a system before building it, so it's a good idea to write a specification of a system before implementing it.This book is about specifying the behavioral properties of a systemalso called its functional or logical properties. These are the properties that specify what the system is supposed to do. There are other important kinds of properties that we don't consider, including performance properties. Worst-case performance can often be expressed as a behavioral propertyforexample, Chapter 9 explains how to specify that a system must react within a certain length of time. However, specifying average performance is beyond the scope of the methods described here.Our basic tool for writing specifications is mathematics. Mathematics is nature's way of letting you know how sloppy your writing is. It's hard to be precise in an imprecise language like English or Chinese. In engineering, imprecision can lead to errors. To avoid errors, science and engineering have adopted mathematics as their language.The mathematics we use is more formal than the math you've grown up with. Formal mathematics is nature's way of letting you know how sloppy your mathematics is. The mathematics written by most mathematicians and scientists is not really precise. It's precise in the small, but imprecise in the large. Each equation is a precise assertion, but you have to read the accompanying words to understand how the equations relate to one another and exactly what the theorems mean. Logicians have developed ways of eliminating those words and making the mathematics completely formal, and hence completely precise.Most mathematicians and scientists think that formal mathematics, without words, is long and tiresome. They're wrong. Ordinary mathematics can be expressed compactly in a precise, completely formal language. It takes only about two dozen lines to define the solution to an arbitrary differential equation in the Differential Equations module of Chapter 11. But few specifications need such sophisticated mathematics. Most require only simple application of a few standard mathematical concepts.Why TLA+?We specify a system by describing its allowed behaviorswhat it may do in the course of an execution. In 1977, Amir Pnueli introduced the use of temporal logic for describing system behaviors. In principle, a system could be described by a single temporal logic formula. In practice, it couldn't. Pnueli's temporal logic was ideal for describing some properties of systems, but awkward for others. So, it was usually combined with a more traditional way of describing systems.In the late 1980s, I invented TLA, the Temporal Logic of Actionsa simple variant of Pnueli's original logic. TLA makes it practical to describe a system by a single formula. Most of a TLA specification consists of ordinary, nontemporal mathematics. Temporal logic plays a significant role only in describing those properties that it's good at describing. TLA also provides a nice way to formalize the style of reasoning about systems that has proved to be most effective in practicea style known as assertional reasoning. However, this book is about specification; it says almost nothing about proofs.Temporal logic assumes an underlying logic for expressing ordinary mathematics. There are many ways to formalize ordinary math. Most computer scientists prefer one that resembles their favorite programming language. I chose instead the one that most mathematicians preferthe one logicians call first-order logic and set theory.TLA provides a mathematical foundation for describing systems. To write specifications, we need a complete language built atop that foundation. I initially thought that this language should be some sort of abstract programming language whose semantics would be based on TLA. I didn't know what kind of programming language constructs would be best, so I decided to start writing specifications directly in TLA. I intended to introduce programming constructs as I needed them. To my surprise, I discovered that I didn't need them. What I needed was a robust language for writing mathematics.Although mathematicians have developed the science of writing formulas, they haven't turned that science into an engineering discipline. They have developed notations for mathematics in the small, but not for mathematics in the large. The specification of a real system can be dozens or even hundreds of pages long. Mathematicians know how to write 20-line formulas, not 20-page formulas. So, I had to introduce notations for writing long formulas. What I took from programming languages were ideas for modularizing large specifications.The language I came up with is called TLA+. I refined TLA+ in the course of writing specifications of disparate systems. But it has changed little in the last few years. I have found TLA+ to be quite good for specifying a wide class of systemsfrom program interfaces (APIs) to distributed systems. It can be used to write a precise, formal description of almost any sort of discrete system. It's especially well suited to describing asynchronous systemsthat is, systems with components that do not operate in strict lock-step.About This BookPart I, consisting of Chapters 1 through 7, is the core of the book and is meant to be read from beginning to end. It explains how to specify the class of properties known as safety properties. These properties, which can be specified with almost no temporal logic, are all that most engineers need to know about. After reading Part I, you can read as much of Part II as you like. Each of its chapters is independent of the others. Temporal logic comes to the fore in Chapter 8, where it is used to specify the additional class of properties known as liveness properties. Chapter 9 describes how to specify real-time properties, and Chapter 10 describes how to write specifications as compositions. Chapter 11 contains more advanced examples. The three chapters in Part III serve as the reference manual for three TLA+ tools: the Syntactic Analyzer, the TLATEX typesetting program, and the TLC model checker. If you want to use TLA+, then you probably want to use these tools. They are available from the TLA Web page. TLC is the most sophisticated of them. The examples on the Web can get you started using it, but you'll have to read Chapter 14 to learn to use TLC effectively.Part IV is a reference manual for the TLA+ language. Part I provides a good enough working knowledge of the language for most purposes. You need look at Part IV only if you have questions about the fine points of the syntax and semantics. Chapter 15 gives the syntax of TLA+. Chapter 16 describes the precise meanings and the general forms of all the built-in operators of TLA+; Chapter 17 describes the precise meaning of all the higher-level TLA+ constructs such as definitions. Together, these two chapters specify the semantics of the language. Chapter 18 describes the standard modulesexcept for module RealTime, described in Chapter 9, and module TLC, described in Chapter 14. You might want to look at this chapter if you're curious about how standard elementary mathematics can be formalized in TLA+.Part IV does have something you may want to refer to often: a mini-manual that compactly presents lots of useful information. Pages 268-273 list all TLA+ operators, all user-definable symbols, the precedence of all operators, all operators defined in the standard modules, and the ASCII representation of symbols.
Data Structures and Algorithms.
Databases and Transaction Processing: An Application-Oriented Approach
The AWK Programming Language
The Java Virtual Machine Specification
Compilers: Princiles, Techniques, and Tools.
Algorithms
This presentation is a tutorial on AutoView, an AutoMod extension package that recreates model animation according to a user-defined script. AutoView allows users to restart animation and move back and forth in time and 3-D space. Animation is created using text files generated from an AutoMod simulation model. By creating a user-defined camera description file, animation can take place that allows for panning from one view to another, as well as for attaching the camera to a simulated load or vehicle and traveling with that entity during portions of the animation. The animation is provided at an enhanced response time because it does not have the logical and statistical processes of AutoMod (which can slow animation). This tutorial demonstrates several animation scripts previously constructed with AutoView, discusses the creation of AutoView files from AutoMod, and describes the development of a camera description file.
The Java Programming Language
Algorithms, 2nd Edition
The Java Programming Language, Second Edition
Operating System Concepts, 4th edition.
The Java Programming Language, Third Edition
The TeXbook
Modern Information Retrieval
:This is a rigorous and complete textbook for a first course on information retrieval from the computer science (as opposed to a user-centred) perspective. The advent of the Internet and the enormous increase in volume of electronically stored information generally has led to substantial work on IR from the computer science perspective - this book provides an up-to-date student oriented treatment of the subject.
Conceptual Structures: Information Processing in Mind and Machine
Concurrency Control and Recovery in Database Systems.
Code Reading: The Open Source Perspective
Intelligent Database Systems
:a valuable resource for anyone working on intelligent database systems. Good background coverage of both the field of databases and that of AI are provided in the first part of the book, and later there are some excellent analytical discussions of relevant projects. The authors adopt a very readable style which enables a complex topic to become much more accessible." - Jenny Carter, Department of Computer Science, De Montfort University This book provides a state of the art guide to the new developments in expert database systems, from the unique perspective of both the database and AI areas. It gives complete and detailed coverage of the latest research and practice, including all the need-to-know technical and theoretical approaches in the area. Drawing on their extensive experience, the authors evaluate how AI techniques can be integrated with present and future database systems and knowledge based management systems, incorporating AI expertise into system design. The book also addresses the techniques developed recently which are directly used, or are the basis, for data retrieval across the world wide web. If you are a designer or developer working in the database community, with database and AI products or applications, this book will help you to understand crucial research developments and to apply the results in practice. Includes: &middot; Mechanisms for handling data and knowledge including XML, web indexing, search engines & data mining &middot; Object Oriented Database Management Systems and object-relational DBMS &middot; Data modeling including techniques suchas Entity Relationship, Functional Data & Semantic Database models, as well as using the notations for modeling (OMT & UML) Plus! Extended case studies of commercial systems About the authors: Elisa Bertino is a well known expert in the integration of AI and database techniques, areas of O-O, distributed, deductive and multimedia databases and database security. She has chaired and given tutorials at many international conferences and published hundreds of journal papers and a book. Elisa is currently a professor of computer science at the University of Milan. Barbara Catania is an assistant professor of computer science at the University of Genova, specializing in deductive and multimedia databases, and indexing techniques in object-oriented and constraint databases. She has presented at a number of international conferences and co-authored a book. Gian Piero Zarri is an internationally renowned consultant and researcher in the areas of knowledge-based systems, natural-language processing, databases and information retrieval systems. He is on the editorial board of a number of international scientific journals and on the program committee of many conferences on Knowledge-Based Systems. Gian Piero currently works as Research Director for CNRS, the French National Centre for Scientific Research.
How to Set Up and Maintain a World Wide Web Site: The Guide for Information Providers.
Object-Oriented Database Systems
Advanced Programming in the UNIX Environment
PROLOG Programming for Artificial Intelligence, Second Edition
TCP/IP Illustrated, Volume 1: The Protocols
TCP/IP Illustrated, Volume 1 is a complete and detailed guide to the entire TCP/IP protocol suite - with an important difference from other books on the subject. Rather than just describing what the RFCs say the protocol suite should do, this unique book uses a popular diagnostic tool so you may actually watch the protocols in action.By forcing various conditions to occur - such as connection establishment, timeout and retransmission, and fragmentation - and then displaying the results, TCP/IP Illustrated gives you a much greater understanding of these concepts than words alone could provide. Whether you are new to TCP/IP or you have read other books on the subject, you will come away with an increased understanding of how and why TCP/IP works the way it does, as well as enhanced skill at developing aplications that run over TCP/IP.
Database Security.
TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP, and the UNIX Domain Protocolls
Object Data Management: Object-Oriented and Extended Relational Database Systems
Object Data Management: Object-Oriented and Extended Relational Database Systems (Revised Edition)
The C++ Programming Language, First Edition
Designing Database Applications with Objects and Rules: The IDEA Methodology
The C++ Programming Language, Second Edition
The Java Developers Almanac 1999
Introduction to Data Mining
The Java Class Libraries - An Annotated Reference
Datenmodelle, Datenbanksprachen und Datenbank-Management-Systeme
The Java Class Libraries, Second Edition, Volume 2
Datenmodelle, Datenbanksprachen und Datenbank-Management-Systeme. 2. Auflage
The Java Class Libraries, Second Edition, Volume 1
Das DB2-Handbuch.
The Java Class Libraries, Second Edition, Volume 1, Supplement for the Java 2 Platform Standard Edition, v1.2
Time Series Prediction: Forecasting the Future and Understanding the Past.
The Relational Model for Database Management, Version 2
From the Preface (See Front Matter for full Preface) An important adjunct to precision is a sound theoretical foundation. The relational model is solidly based on two parts of mathematics: firstorder predicate logic and the theory of relations. This book, however, does not dwell on the theoretical foundations, but rather on all the features of the relational model that I now perceive as important for database users, and therefore for DBMS vendors. My perceptions result from 20 years of practical experience in computing and data processing (chiefly, but not exclusively, with large-scale customers of IBM), followed by another 20 years of research. I believe that this is the first book to deal exclusively with the relational approach. It does, however, include design principles in Chapters 21 and 22. It is also the first book on the relational model by the originator of that model. All the ideas in the relational model described in this book are mine, except in cases where I explicitly credit someone else. In developing the relational model, I have tried to follow Einstein's advice, "Make it as simple as possible, but no simpler." I believe that in the last clause he was discouraging the pursuit of simplicity to the extent of distorting reality. So why does the book contain 30 chapters and two appendixes? To answer this question, it is necessary to look at the history of research and development of the relational model.
Java Platform Performance - Strategies and Tactics
:This book addresses a vital issue for all those developing software for the Java™ platform: how to achieve maximum performance and scalability for their applications. Drawing on the authors' knowledge of the Java programming language and their extensive experience working on performance issues, the book reveals common mistakes and misconceptions concerning the performance characteristics of Java technologies. It offers overall development strategies and concrete, battle-tested techniques to dramatically improve the performance of applications constructed with the Java programming language. Java™ Platform Performance highlights the importance of integrating performance evaluation into the application development process and discusses measurement techniques. The book then presents practical tactics for enhancing application performance in the areas of I/O, RAM footprint, small object management, algorithms, data structures, Swing, and deployment. Specific topics covered include: Incorporating performance evaluation into the development process Profiling and benchmarking Building scalable, fast Swing GUIs Using high-speed I/O Computing and controlling the RAM footprint Reducing the number of classes Eliminating temporary objects Selecting high-performance algorithms and data structures Using Java native code and applet packaging efficiently Garbage collection Java HotSpot™ technology With an understanding of the performance issues and specific techniques for reducing overhead discussed in this book, you will have theinformation you need to enhance the efficiency, speed, and scalability of your software.
Advanced C++: Programming Syles and Idioms
Deductive Databases and Logic Programming
High performance compilers for parallel computing
An Introduction to Database Systems
:The sixth edition of this well-respected text/reference--which has been almost completely rewritten--continues to be the most comprehensive and up-to-date treatment of database technology currently available. Readers will gain a strong working knowledge of the overall structure, concepts, and objectives of database systems and will become familiar with the theoretical principles underlying the construction of such systems.
TCP/IP Illustrated, Volume 2: The Implementation
An Introduction to Database Systems, 2nd Edition
Human Behaviour and the Principle of Least Effort: an Introduction to Human Ecology
An Introduction to Database Systems, 3rd Edition
:For over 25 years, C. J. Date's An Introduction to Database Systems has been the authoritative resource for readers interested in gaining insight into and understanding of the principles of database systems. This revision continues to provide a solid grounding in the foundations of database technology and to provide some ideas as to how the field is likely to develop in the future.. "Readers of this book will gain a strong working knowledge of the overall structure, concepts, and objectives of database systems and will become familiar with the theoretical principles underlying the construction of such systems.
The INGRES Papers: Anatomy of a Relational Database System
An Introduction to Database Systems, Volume II.
A Guide to DB2, 1st Edition
An Introduction to Database Systems, Volume I, 4th Edition.
An Introduction to Database Systems, Volume I, 5th Edition.
An Introduction to Database Systems, 6th Edition.
Relational Database Writings 1989-1991
A Guide to SQL Standard, 3rd Edition
A Guide to SQL Standard, 4th Edition
A Guide to DB2, 2nd Edition
A Guide to DB2, 3rd Edition
Cryptography and Data Security
From the Preface (See Front Matter for full Preface) Electronic computers have evolved from exiguous experimental enterprises in the 1940s to prolific practical data processing systems in the 1980s. As we have come to rely on these systems to process and store data, we have also come to wonder about their ability to protect valuable data. Data security is the science and study of methods of protecting data in computer and communication systems from unauthorized disclosure and modification. The goal of this book is to introduce the mathematical principles of data security and to show how these principles apply to operating systems, database systems, and computer networks. The book is for students and professionals seeking an introduction to these principles. There are many references for those who would like to study specific topics further. Data security has evolved rapidly since 1975. We have seen exciting developments in cryptography: public-key encryption, digital signatures, the Data Encryption Standard (DES), key safeguarding schemes, and key distribution protocols. We have developed techniques for verifying that programs do not leak confidential data, or transmit classified data to users with lower security clearances. We have found new controls for protecting data in statistical databases--and new methods of attacking these databases. We have come to a better understanding of the theoretical and practical limitations to security.
The Annotated C++ Reference Manual.
Functional Programming
Relational Databases and Knowledge Bases
Natural Language Processing in PROLOG
Genetic Algorithms in Search Optimization and Machine Learning
Smalltalk-80: The Language and Its Implementation.
From the Preface (See Front Matter for full Preface) Advances in the design and production of computer hardware have brought many more people into direct contact with computers. Similar advances in the design and production of computer software are required in order that this increased contact be as rewarding as possible. The Smalltalk-80 system is a result of a decade of research into creating computer software that is appropriate for producing highly functional and interactive contact with personal computer systems. This book is the first detailed account of the Smalltalk-80 system. It is divided into four major parts: Part One -- an overview of the concepts and syntax of the programming language. Part Two -- an annotated and illustrated specification of the system's functionality. Part Three -- an example of the design and implementation of a moderate-size application. Part Four -- a specification of the Smalltalk-80 virtual machine.
The Java Language Specification.
A Retargetable C Compiler: Design and Implementation
Objektorientierte Datenbanken: Konzepte, Modelle, Systeme.
Objektorientierte Datenbanken: Konzepte, Modelle, Systeme, 2. Auflage.
Introduction to Automata Theory, Languages and Computation.
An Introduction to Parallel Algorithms
Introduction to Expert Systems, 1st Edition.
Introduction to Expert Systems, 2nd Edition.
:The third edition of Peter Jackson's book, Introduction to Expert Systems, updates the technological base of expert systems research and embeds those results in the context of a wide variety of application areas. The earlier chapters take a more practical approach to the basic topics than the previous editions, while the later chapters introduce new topic areas, such as case-based reasoning, connectionist systems, and hybrid systems. Results in related areas, such as machine learning and reasoning with uncertainty are also accorded a thorough treatment.
Introduction to Expert Systems, 3rd Edition.
:The third edition of Peter Jackson's book, Introduction to Expert Systems, updates the technological base of expert systems research and embeds those results in the context of a wide variety of application areas. The earlier chapters take a more practical approach to the basic topics than the previous editions, while the later chapters introduce new topic areas, such as case-based reasoning, connectionist systems, and hybrid systems. Results in related areas, such as machine learning and reasoning with uncertainty are also accorded a thorough treatment.
The Practice of Programming
Object-Oriented Concepts, Databases, and Applications.
The Art of Computer Programming, Volume I: Fundamental Algorithms
The Art of Computer Programming, Volume II: Seminumerical Algorithms
The Art of Computer Programming, Volume III: Sorting and Searching
The Art of Computer Programming, Volume I: Fundamental Algorithms, 2nd Edition.
The Art of Computer Programming, Volume II: Seminumerical Algorithms, 2nd Edition
Inside the C++ Object Model
Inside the C++ Object Model focuses on the underlying mechanisms that support object-oriented programming within C++: constructor semantics, temporary generation, support for encapsulation, inheritance, and "the virtuals"-virtual functions and virtual inheritance. This book shows how your understanding the underlying implementation models can help you code more efficiently and with greater confidence. Lippman dispells the misinformation and myths about the overhead and complexity associated with C++, while pointing out areas in which costs and trade offs, sometimes hidden, do exist. He then explains how the various implementation models arose, points out areas in which they are likely to evolve, and why they are what they are. He covers the semantic implications of the C++ object model and how that model affects your programs.Highlights Explores the program behavior implicit in the C++ Object Model's support of object-oriented programming. Explains the basic implementation of the object-oriented features and the trade offs implicit in those features. Examines the impact on performance in terms of program transformation. Provides abundant program examples, diagrams, and performance measurements to relate object-oriented concepts to the underlying object model.If you are a C++ programmer who desires a fuller understanding of what is going on "under the hood," then Inside the C++ Object Model is for you!
Introduction to Linear and Nonlinear Programming.
Design of Relational Databases
Tcl and the Tk Toolkit
From the Book:Tcl was born of frustration. In the early 1980s my students and I developed a number of interactive tools at the University of California at Berkeley, mostly for integrated circuit design, and we found ourselves spending a lot of time building bad command languages. Each tool needed to have a command language of some sort, but our main interest was in the tool rather than its command language. We spent as little time as possible on the command language and always ended up with a language that was weak and quirky. Furthermore, the command language for one tool was never quite right for the next tool, so we ended up building a new bad command language for each tool. This became increasingly frustrating.In the fall of 1987 it occurred to me that the solution was to build a reusable command language. If a general-purpose scripting language could be built as a C library package, then perhaps it could be reused for many different purposes in many different applications. Of course, the language would need to be extensible so that each application could add its own specific features to the core provided by the library. In the spring of 1988 I decided to implement such a language, and the result was Tcl. Tk was also born of frustration. The basic idea for Tk arose in response to Apple's announcement of HyperCard in the fall of 1987. HyperCard generated tremendous excitement because of the power of the system and the way in which it allowed many different interactive elements to be scripted and work together. However, I was discouraged. The HyperCard system had obviously taken a large development effort, and it seemed unlikely to me that a small group such as a university researchproject could ever mount such a massive effort. This suggested that we would not be able to participate in the development of new forms of interactive software in the future.I concluded that the only hope for us was a component approach. Rather than building a new application as a self-contained monolith with hundreds of thousands of lines of code, we needed to find a way to divide applications into many smaller reusable components. Ideally each component would be small enough to be implemented by a small group, and interesting applications could be created by assembling components. In this environment it should be possible to create an exciting new application by developing one new component and then combining it with existing components.The component-based approach requires a powerful and flexible "glue"for assembling the components, and it occurred to me that perhaps a shared scripting language could provide that glue. Out of this thinking grew Tk, an X11 toolkit based on Tcl. Tk allows components to be either individual user-interface controls or entire applications; in either case components can be developed independently and Tcl can be used to assemble the components and communicate between them.I started writing Tcl and Tk as a hobby in my spare time. As other people began to use the systems I found myself spending more and more time on them, to the point where today they occupy almost all of my waking hours and many of my sleeping ones.Tcl and Tk have succeeded beyond my wildest dreams. The Tcl/Tk developer community now numbers in the tens of thousands and there are thousands of Tcl applications in existence or under development. The application areas for Tcl and Tk cover virtually the entire spectrum of graphical and engineering applications, including computer-aided design, software development, testing, instrument control, scientific visualization, and multimedia. Tcl is used by itself in many applications, and Tcl and Tk are used together in many others. Tcl and Tk are being used by hundreds of companies, large and small, as well as universities and research laboratories.One benefit that came as a surprise to me is that it is possible to create interesting graphical user interfaces (GUIs) entirely as Tcl scripts. I had always assumed that every Tcl application would contain some new C code that implements new Tcl commands, plus some Tcl scripts that combine the new commands with the built-in facilities provided by Tcl. However, once a simple Tcl/Tk application called wish became available, many people began creating user interfaces by writing Tcl scripts for it, without writing any C code at all! It turned out that the Tcl and Tk commands provide a high-level interface to GUI programming that hides many of the details faced by a C programmer. As a result, it is much easier to learn how to use wish than a C-based toolkit, and user interfaces can be written with much less code. Most Tcl/Tk users never write any C code at all and most of the Tcl/Tk applications consist solely of Tcl scripts.This book is intended as an introduction to Tcl and Tk for programmers who plan to write or modify Tcl/Tk applications. I assume that readers have programmed in C and have at least passing familiarity with a shell such as sh or csh or ksh. I also assume that readers have used the X Window System and are familiar with basic ideas such as using the mouse, resizing windows, etc. No prior experience with Tcl or Tk is needed in order to read this book, and you need not have written X applications using other toolkits such as Motif.The book is organized so that you can learn Tcl without learning Tk if you wish. Also, the discussion of how to write Tcl scripts is separate from the discussion of how to use the C library interfaces provided by Tcl and Tk. The first two parts of the book describe Tcl and Tk at the level of writing scripts, and the last two parts describe the C interfaces for Tcl and Tk; if you are like the majority of Tcl/Tk users who only write scripts, you can stop after reading the first two parts.In spite of my best efforts, I'm sure that there are errors in this edition of the book. I'm interested in hearing about any problems that you encounter, whether they are typos, formatting errors, sections or ideas that are hard to understand, or bugs in the examples. I'll attempt to correct the problems in future printings of the book. The best way to report problems is with electronic mail sent to tclbookbugs@cs.berkeley.edu.Many people have helped in the creation of this book. First and foremost I would like to thank Brian Kernighan, who reviewed several drafts of the manuscript with almost terrifying thoroughness and uncovered numerous problems both large and small. I am also grateful for the detailed comments provided by the other Addison-Wesley technical reviewers: Richard Blevins, Gerard Holzmann, Curt Horkey, Ron Hutchins, Stephen Johnson, Oliver Jones, David Korn, Bill Leggett, Don Libes, Kent Margraf, Stuart McRobert, David Richardson, Alexei Rodrigues, Gerald Rosenberg, John Slater, and Win Treese. Thanks also to Bob Sproull, who read the next-to-last draft from cover to cover and provided countless bug fixes and suggestions.I made early drafts of the manuscript available to the Tcl/Tk community via the Internet and received countless comments and suggestions from all over the world in return. I'm afraid that I didn't keep careful enough records to acknowledge all the people who contributed in this way, but the list of contributors includes at least the following people: Marvin Aguero, Miriam Amos Nihart, Jim Anderson, Frederik Anheuser, Jeff Blaine, John Boller, David Boyce, Terry Brannon, Richard Campbell, J. Cazander, Wen Chen, Richard Cheung, Peter Chubb, De Clarke, Peter Collinson, Peter Costantinidis, Alistair Crooks, Peter Davies, Tal Dayan, Akim Demaille, Mark Diekhans, Matthew Dillon, Tuan Doan, Tony Duarte, Paul DuBois, Anton Eliens, Marc R. Ewing, Luis Fernandes, Martin Forssen, Ben Fried, Matteo Frigo, Andrej Gabara, Steve Gaede, Sanjay Ghemawat, Bob Gibson, Michael Halle, Jun Hamano, Stephen Hansen, Brian Harrison, Marti Hearst, Fergus Henderson, Kevin Hendrix, David Herron, Patrick Hertel, Carsten Heyl, Leszek Holenderski, Jamie Honan, Rob W.W. Hooft, Nick Hounsome, Christopher Hylands, Jonathan Jowett, Poul-Henning Kamp, Karen L. Karavanic, Sunil Khatri, Vivek Khera, Jon Knight, Roger Knopf, Ramkumar Krishnan, Dave Kristol, Peter LaBelle, Tor-Erik Larsen, Tom Legrady, Will E. Leland, Kim Lester, Joshua Levy, Don Libes, Oscar Linares, David C.P. Linden, Toumas J. Lukka, Steve Lord, Steve Lumetta, Earlin Lutz, David J. Mackenzie, B.G. Mahesh, John Maline, Graham Mark, Stuart McRobert, George Moon, Michael Morris, Russell Nelson, Dale K. Newby, Richard Newton, Peter Nguyen, David Nichols, Marty Olevitch, Rita Ousterhout, John Pierce, Stephen Pietrowicz, Anna Pluzhnikov, Nico Poppelier, M.V.S. Ramanath, Cary D. Renzema, Mark Roseman, Samir Tiongson Saxena, Jay Schmidgall, Dan M. Serachitopol, Hume Smith, Frank Stajano, Larry Streepy, John E. Stump, Michael Sullivan, Holger Teutsch, Bennett E. Todd, Glenn Trewitt, D.A. Vaughan-Pope, Richard Vieregge, Larry W. Virden, David Waitzman, Matt Wartell, Glenn Waters, Wally Wedel, Juergen Weigert, Mark Weiser, Brent Welch, Alex Woo, Su-Lin Wu, Kawata Yasuro, Chut Ngeow Yee, Richard Yen, Stephen Ching-SingYen, and Mike Young.Many many people have made significant contributions to the development of Tcl and Tk. Without all of their efforts there would have been nothing of interest to write about in this book. Although I cannot hope to acknowledge all the people who helped to make Tcl and Tk what they are today, I would like to thank the following people specially: Don Libes, for writing the first widely used Tcl application; Mark Diekhans and Karl Lehenbauer, for TclX; Alastair Fyfe, for supporting the early development of Tcl; Mary Ann May-Pumphrey, for developing the original Tcl test suite; George Howlett, Michael McLennan, and Sani Nassif, for the BLT extensions; Kevin Kenny, for showing that Tcl can be used to communicate with almost any imaginable program; Joel Bartlett, for many challenging conversations and for inspiring Tk's canvas widget with his ezd program; Larry Rowe, for developing Tcl-DP and for providing general advice and support; Sven Delmas, for developing the XF application builder based on Tk; and Andrew Payne, for the widget tour and for meritorious Tcl evangelism.Several companies have provided financial support for the development of Tcl and Tk, including Digital Equipment Corporation, Hewlett-Packard Corporation, Sun Microsystems, and Computerized Processes Unlimited. I am particularly grateful to Digital's Western Research Laboratory and its director, Richard Swan, for providing me with a one-day-per-week hideaway where I could go to gather my thoughts and work on Tcl and Tk.Terry Lessard-Smith and Bob Miller have provided fabulous administrative support for this and all my other projects. I don't know how I would get anything done without them.Finally, I owe a special debt to my colleague and friend Dave Patterson, whose humor and sage advice have inspired and shaped much of my professional career, and to my wife Rita and daughters Kay and Amy, who have tolerated my workaholic tendencies with more cheer and affection than I deserve. John Ousterhout Berkeley, California February, 1994
Functional Programming and Parallel Graph Rewriting
Web Caching and Replication
Web caching and replication provides essential material based on the extensive real-world experience of two experts from AT & T Labs. This comprehensive examination of caching, replication, and load-balacing practices for the Web brings together information from and for the commercial world, including real-life products; technical standards communities, such as IETF and W3C; and academic research.
Mehrrechner-Datenbanksysteme - Grundlagen der verteilten und parallelen Datenbankverarbeitung.
Advanced Prolog: Techniques and Examples
Automatic Text Processing: The Transformation, Analysis, and Retrieval of Information by Computer.
The Design and Analysis of Spatial Data Structures
Temporal Deductive Databases.
The Historical Relational Data Model (HRDM) Revisited.
On the Completeness of Query Languages for Grouped and Ungrouped Historical Data Models.
A Temporal Model and Query Language for EER Databases.
The Time Index and the Monotonic B+-tree.
Ben-Zvi's Pioneering Work in Relational Temporal Databases.
Temporal Databases: A Prelude to Parametric Data.
Object and Spreadsheet Histories.
Differential Query Processing in Transaction-Time Databases.
Indexing Techniques for Historical Databases.
Stream Processing: Temporal Query Processing and Optimization.
Transaction-Time Databases.
The Interval-extended Relational Model and Its Applications to Valid-time Databases.
temporal Reasoning.
Temporal Extensions to the Relational Model and SQL.
HSQL: A Historical Query Language.
Join Processing and Optimization in Temporal Relational Databases.
A Temporal Data Model Based on Time Sequences.
An Overview of TQuel.
A Generalized relational Framework for Modeling Temporal Data.
Applications of temporal Databases to Knowledge-based Simulations.
Integrating Temporal Data in a Heterogeneous Environment.
A Uniform Model for Temporal and Versioned Object-oriented Databases.
Relational Database Theory
Conceptual Database Design: An Entity-Relationship Approach.
Object-Oriented Design with Applications
Fundamentals of Database Systems
Fundamentals of Database Systems, 2nd Edition.
:Fundamentals of Database Systems combines clear explanations of theory and design, broad coverage of models and real systems, and excellent examples with up-to-date introductions to modern database technologies. This edition is completely revised and updated, and reflects the latest trends in technological and application development. Professors Elmasri and Navathe focus on the relational model and include coverage of recent object-oriented developments. They also address advanced modeling and system enhancements in the areas of active databases, temporal and spatial databases, and multimedia information systems. This edition also surveys the latest application areas of data warehousing, data mining, web databases, digital libraries, GIS, and genome databases. New to the Third Edition Reorganized material on data modeling to clearly separate entity relationship modeling, extended entity relationship modeling, and object-oriented modeling Expanded coverage of the object-oriented and object/relational approach to data management, including ODMG and SQL3 Uses examples from real database systems including OracleTM and Microsoft AccessAE Includes discussion of decision support applications of data warehousing and data mining, as well as emerging technologies of web databases, multimedia, and mobile databases Covers advanced modeling in the areas of active, temporal, and spatial databases Provides coverage of issues of physical database tuning Discusses current database application areas of GIS, genome, and digital libraries
Crafting a Compiler with C
Introduction to Parallel Computing.
Computing with Logic: Logic Programming with Prolog
Temporal Databases: Theory, Design, and Implementation
Automaten, Sprachen und Maschinen für Anwender
Rechnerorganisation
Rechnerorganisation, 2. Auflage
Computer-Grafik
Computer-Grafik, 2. Auflage
Planen: Einführung in die Planerstellungsmethoden der künstlichen Intelligenz
Kryptologie
Theoretische Grundlagen relationaler Datenbanksysteme
Rechnernetzwerksystemarchitekturen und Datenkommunikation
Datenbankmaschinen: Performanz durch Parallelität
Parallele Transaktionen in Datenbanksystemen
Syntaxanalyse, 3. Auflage
C
Algorithmen und Datenstrukturen
Algorithmen und Datenstrukturen, 2. Auflage
Künstliche Intelligenz: Überblick und Grundlagen; grundlegende Konzepte und Methoden zur Realisierung von Systemen der künstlichen Intelligenz
Geo-Datenbanksysteme: Eine Speicher- und Zugriffsarchitektur
Logik für Informatiker
Logik für Informatiker, 2. Auflage
Logik für Informatiker, 3. Auflage
Softwaretechnologie: Eine Einführung, 3. Auflage
Softwaretechnologie: Eine Einführung, 4. Auflage
Mikroprozessoren: vom Bauteil zur Anwendung, 2. Auflage
Objektorientierte Schemaentwicklung: Ein kategorialer Ansatz für Datenbanken und Programmierung
Datenbanksysteme I
Datenbanksysteme II
Datenbanksysteme I, 2. Auflage
Datenbanksysteme I, 3. Auflage
Compilerbau I: Analyse
Compilerbau II: Synthese und Optimierung
Betriebssysteme: Parallele Prozesse, 3. Auflage
Compilerbau I: Analyse, 2. Auflage
Information Retrieval.
Building an Optimizing Compiler.
Introduction to Knowledge Base Systems
Debuggers for Programming Languages.
Software Pipelining.
Compilation for Distributed Memory Architectures.
Dynamic Compilation.
Register Allocation.
Instruction Scheduling.
Data Flow Testing.
Profile-Guided Compiler Optimizations.
Data Flow Analysis.
Optimizations for Object-Oriented Languages.
Program Slicing.
Automatic Generation of Code Optimizers from Formal Specifications.
Introduction to Operational Semantics.
Architecture Description Languages for Retargetable Compilation.
Retargetable Very Long Instuction Word Compiler Framework for Digital Signal Processors.
Dependence Analysis and Parallelizing Transformations.
Automatic Data Distribution.
Instruction Selection Using Tree Parsing.
Scalar Compiler Optimizations on the Static Single Assignment Form and the Flow Graph.
Type Systems in Programming Languages.
Compiling Safe Mobile Code.
Shape Analysis and Applications.
A Comparative Case Study of Distributed Network Architectures for Different Automotive Applications.
LonWorks/EIA-709 Networks EIA 709 Protocol (Lon Talk).
Distributed Components in Microsoft Platforms - Technology Overview.
The Quest for Real-Time Behavior in Ethernet.
CORBA in Manufacturing - Technology Overview.
IPv6, IPSec, and VPNs.
Overview and Classification of IP Routing Protocols - IP Routing: Interior and Exterior Routing Protocols.
Java Technology and Industrial Applications.
Internal Architecture and Features of Real-Time Embedded Operation Systems.
Middleware.
Network On-Chip Design for Gigascale Systems-on-Chip.
Principles and Features of PROFINET.
Knowledge Connect - An Approach for an Industrial IT Service Tool.
Intelligent Space and Mobile Robots.
Software for Wireless Sensor Networks.
Web-based Enterprise Computing Development using J2EE.
Holonic Manufacturing Systems: A Technical Overview.
The GRAFCET Specification Language.
The IDA Standard.
Embedded Software in the SoC World. The Concept of HdS in View of the HW and SW Design Challenge.
Platform-Based and Derivative Design.
Internet Programming Languages.
FOUNDATION Fieldbus: History and Features.
MPLS - Multiprotocol Label Switching.
Operating Principles and Features of CAN Networks.
Robot Tactile Sensing.
Hardware/Software Interfaces Design for SoC.
Giving Robots a Sense of Smell.
Mail Transfer and File Transfer Protocol.
The Integrated Services Architecture and RSVP.
Collaborative (Agent-Based) Factory Automation.
Linking Factory Floor and the Internet.
Which Network for Which Application.
Internet Firewalls.
Interconnection of Wireline and Wireless Fieldbusses.
IEEE 1394 for Factory Automation.
Intelligent Sensors: Analysis and Design.
Securtity in Automation Networks.
Integration Technologies of Field Devices in Distributed Control and Engineering Systems.
The Standard Message Specification for Industrial Automation Systems -ISO 9506 (MMS).
RTP, RTCP, and RTSP - Internet Protocols for Real-Time Multimedia Communication.
Smart Power Systems Rely on Standards for Information Models and Messaging - IEC 61850.
The Fundamentals of Web Services.
Open System Architecture for Controls within Automation Systems (OSACA).
Programming Web Services with .net and java.
A Survey of Congestion and QoS Control Mechanisms for the Internet.
Languages for Embedded Systems.
Switched Ethernet in Automation Networking.
Enterprise-Manufacturing Data Exchange Using XML.
Programming with the IEC 61131-3 Languages and the MatPLC.
The Dynamic Host Configuration Protocol.
Security in Embedded Systems.
The Internet Protocol.
PROFIsafe - Safety Technology with PROFIBUS.
ARP - Address Resolution Protocol.
XML for the Exchange of Automation Project Information.
The WORLDFIP Fieldbus.
IP-Mobility for Cellular and Wireless Networks.
Unified Modeling Language: The Industry Standard for Software Development.
A Survey on Self-Organizing Wireless Sensor Networks.
Web Servers, Clients, and Browsers.
The Hypertext Transfer Protocol and Uniform Resource Identifier.
Introduction to Multisensor Data Fusion.
Models of Computation for Embedded Systems.
Industrial IT-Based Network Management.
Hardware-level Design Languages.
Integration Between Production and Business Systems.
From Holonic Control to Virtual Enterprises: The Multi-Agent Approach.
Acheiving Reconfigurability of Automation Systems by Using the New International Standard IEC 61499: A Developer's View.
IP-QoS: Scalable and Flexible Quality-of-Service with Differentiated Services.
Real-Time Systems.
Wireless LAN Technology for the Factory Floor.
Internet Still Image and Video Formats.
Principles of Lower-Layer Protocols for Data Communications.
Network Management: Basic Notions and Frameworks.
Multicast.
HTTP Digest Authentication - Theory and Practice.
Web Services for Integrated Automation Systems - Challenges, Solutions and Future.
Verification Languages.
Mobile IP Routing.
Remote Monitoring and Control over the Internet.
Power Aware Embedded Computing.
Robot Vision.
Bluetooth.
PROFIBUS - Open Solutions for the World of Automation.
The Fundamentals of the Quality of Service.
Ad Hoc Networks.
Applications of Haptics in Design and Manufacturing.
Implementation af a Virtual Factory Communication System using the Manufacturing Message Specification Standard.
Ultrasonic Sensors in Robotics.
Microsoft's .NET.
Multiagent-based Architecture for Plant Automation.
Introduction to e-Manufacturing.
Time-Triggered Communication Networks.
Internet-Based Telemanipulation.
Network Security and Secure Applications.
Simple Network Management Protocol SNMP.
TCP/IP Architecture, Protocols, and Services.
OPC - Openness, Productivity, and Connectivity.
Design of Embedded Systems.
A Smart Transducer Interface Standard for Sensors and Actuators.
LonWorksTM over IP.
The Transmission Control Protocol.
Multidimensional Databases.
The User Datagram protocol.
Networked Control Systems Overview.
System-on-Chip and Network-on-Chip Design.
Wireless Local Area Networks and Wireless Personal Area Networks (WLANs and WPANs).
Open Controller Enabled by an Advanced Real-Time Network (OCEAN).
IT Security for Automation Systems.
The JEVIS Service Platform - Distributed Energy Data Acquisition and Management.
An Introductory Survey of Networked Embedded Systems.
Thread Management for Shared-Memory Multiprocessors.
Parallelizing Compilers.
Renderman®: An Interface for Image Synthesis.
Object-Oriented Databases.
Network and Internet Security.
Concurrent/Distributed Programming Paradigm.
Parallel Algorithms.
Formal Models and the Specification Process.
User Interface Design Activities.
Virtual Reality.
Memory Systems.
Type Systems.
Computational Fluid Dynamics.
Rules in Data-Based Systems.
Combinatorial Optimization.
Distributed and Multiprocessor Scheduling.
Computational Reacting Flow.
Logic Programming and Constraint Logic Programming.
Pattern Matching and Text Compression Algorithms.
Process and Device Scheduling.
Explanation-Based Learning.
Planning and Scheduling.
Traditional Software Design.
Virtual Memory.
Virtual memory is the simulation of a storage space so large that programmers do not need to reprogram or recompile their works when the capacity of a local memory or the configuration of a network changes. The name, borrowed from optics, recalls the virtual images formed by mirrors and lenses--images that are not there but behave as if they are. The designers of the Atlas Computer at the University of Manchester invented virtual memory in the 1950s to eliminate a looming programming problem: planning and scheduling data transfers between main and secondary memory and recompiling programs for each change of size of main memory. Virtual memory is even more useful in the computers of the 1990s, which have more things to hide-on-chip caches, separate RAM chips, local disk storage, network file servers (q.v.), large numbers of separately compiled program modules, other computers on the local bus or local network, or the Internet. The story of virtual memory from then to now is a story about machines helping programmers solve problems in storage allocation, protection of information, sharing and reuse of objects, and linking of program components. Virtual memory, common in all computers and operating systems from the smallest microprocessor to the largest supercomputer, is now invading the Internet.
Algebraic Algorithms.
Distributed File Systems and Distributed Memory.
Real-Time and Embedded Systems.
Output Devices and Techniques.
Interactive Techniques.
Advanced Geometric Modeling.
Digital Logic.
Malicious Software and Hacking.
What Is an Operating System?
Data Structures.
Mainstream Rendering Techniques.
Qualitative Reasoning.
Genetic Algorithms.
Concurrency Control and Recovery.
Verification and Validation.
Software Qualities and Principles.
Functional Programming Languages.
The Organizational Context of Development and Use.
The Object-Oriented Language Paradigm.
Overview of Three-Dimensional Graphics.
International User-Interface Standardization.
Busses.
Parallel Architectures.
Interactive Software Technology.
Computer Vision.
Query Optimization.
Input Devices and Techniques.
Database Security and Privacy.
Formal Models and Computability.
The Imperative Language Paradigm.
Ethical Issues for Computer Scientists and Engineers.
Neural Networks.
We present an overview of current research on artificial neural networks, emphasizing a statistical perspective. We view neural networks as parameterized graphs that make probabilistic assumptions about data, and view learning algorithms as methods for finding parameter values that look probable in the light of the data. We discuss basic issues in representation and learning, and treat some of the practical issues that arise in fitting networks to data. We also discuss links between neural networks and the general formalism of graphical models.
Digital Computer Architecture.
Computational Ocean Modeling.
Volume Visualization.
Graph and Network Algorithms.
Task Analysis and the Design of Functionality.
Computational Biology.
Search.
Case Study in Algorithms: VLSI Layout.
Protection (Security) Models and Policy.
Computational Geometry.
Robotics.
Compilers and Interpreters.
Complexity Theory.
Logic-Based Deductive Reasoning.
Computer Animation.
Secondary Storage and File Systems.
The SQL Language: A Case Study.
Randomized Algorithms.
Overview of Distributed Operating Systems.
Interface Software Technology.
Security and Privacy Issues in Computer and Communication Systems.
Computational Structural Mechanics.
Distributed and Parallel Database Systems.
Routing Protocols.
Development Strategies and Project Management.
Internetworking.
Software Tools and Environments.
Geometric Primitives.
Access Methods.
Testing: Principles and Practice.
Online Support Systems: Tutorials, Documentation, and Help.
Computational Electromagnetics.
Scientific Visualization.
Data Models.
Network Organization and Topologies.
Computer Science and Engineering: The Discipline and Its Impact.
Process Synchronization and Interprocess Communications.
Usability Engineering.
:Written by the author of the best-selling HyperText & HyperMedia, this book provides an excellent guide to the methods of usability engineering. Special features: emphasizes cost-effective methods that will help developers improve their user interfaces immediately, shows you how to avoid the four most frequently listed reasons for delay in software projects, provides step-by-step information about which methods to use at various stages during the development life cycle, and offers information on the unique issues relating to informational usability. You do not need to have previous knowledge of usability to implement the methods provided, yet all of the latest research is covered.
Knowledge-Based Systems for Natural Language Processing.
Run Time Environments and Memory Management.
Database Performance Measurement.
Graphical Models for Probabilistic and Causal Reasoning.
Foundational Calculi for Programming Languages.
Decision Trees and Instance-Based Classifiers.
Basic Techniques for Design and Analysis of Algorithms.
Text Databases and Information Retrieval.
The Human Factor in Programming and Software Development.
Authentication, Access Controls, and Intrusion Detection.
Programming Language Semantics.
Like English, French, and other "natural" languages, a programming language possesses both a syntax (grammatical laws that define the well-formed sentences) and a semantics (rules for giving meaning to programming language is a simple enough "artificial" language that precise definitions can be formulated for its syntax and semantics. The benefits of such precise definitions are: (1) the definitions standardize the programming language, so that implementors and users can agree on how the language bahaves; (2) the definitions can be analyzed for correctness and effciency properties; and (3) they can be used as input to automated prototyping tools like complier generators.
Understanding Spoken Language.
Tuning Database Design for High Performance.
Software Support Challenges for Heterogeneous Computing.
Software Process Models.
Geometry-Grid Generation.
High-Speed Computer Arithmetic.
Sampling, Reconstruction, and Antialiasing.